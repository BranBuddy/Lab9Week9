Observer Pattern: We made a game manager singleton class to start off. Then we made a function that will add a int supplied by the enemy's point value and add it to the player's score. Whenever the enemy dies, then the score is executed.
Builder Pattern: In the enemy class, the base attributes are defined for the enemy. Then in a nested class a function is defined to set those attributes to a set of parameter. Then a build function is called that returns the defined enemy. Then in their own respective classes,
this function is called and assigned different values depending on need

Object Pooling: The object pooling is done through multiple scripts, the first being the ObjectPooling Script which basically creates a set number of deactivated bullets so that they can pulled from by activating and deactivating them. The PrefabIdentifier script is attached to each bullet so that they can each be identified, this way the ObjectPooling script can tell the bullets apart and can tell which bullet is being enabled and disabled. The shoot function in the player script enables the next available bullet from the ObjectPooling script to be fired. Finally, in the Projectile script, the script tells the ObjectPooling script to find the enabled bullet, so that finally, when the specific bullet hits any of the enemies, that specific bullet can be disabled in the object pool to be reused for later.

Saving: At first we had trouble with the concepts presented, but after talking to some classmates i finally understood what i had to do. First i set up my saveable interface that will other classes will inherit. In my transformer saver script i added my interface and wrote down the variables and functions that needed to be inherited. Then i assigned a guid to each saveID. Then in a third script i added the load and save functionality where the objects with  monobehavior and a Isaveable interface are added to a list, saved to a file, and loaded when called.
